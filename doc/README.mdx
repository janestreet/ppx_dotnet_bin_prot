# dotnet_bin_prot

This library is for creating F# types with serialization that is
compatible to existing OCaml types (using bin_prot). Each OCaml type
that is annotated results in a separate F# file. This library relies
on a lot of syntax being similar between F# and OCaml, but handles all
differences we've encountered so far correctly.

There are some limitations as to what types are supported:
1. Mutually recursive types are not supported
2. When generating an F# type for [t] and [Other.t] below

```ocaml skip
type t = Other.t = { ... }
```

we will not have the type equality they will not be type equal. This
is due to F# not supporting the type equality syntax.

There is a `core_with_dotnet` library that should be used on top of
`core` in order to have `dotnet_bin_prot_t` values for some common
types. It also provides alternative functors for creating `Comparable`
modules.

If there are any basic types missing from the library feel free to add
them or reach out to maintainers of `ppx_dotnet_bin_prot`. They are
added lazily and using the ppx to generate the `dotnet_bin_prot_t`
value should ensure it is correct.

## PPX

There is an associated ppx that generates the required metadata for
generating the F# type. Users should be careful when deriving metadata
for types inside of functors, as the source code position of the type
definition is used to compare whether types are equal.

The ppx explicitly defines dependencies which means that if the tree
compiles you should be able to generate all required F# types.

There are three ways of using it ordered by ease of use:
1. Add `dotnet_bin_prot` to a deriving clause, eg:

```ocaml skip
type 'a t = | Variant of ('a * unit) [@@deriving dotnet_bin_prot]
```

2. Use an extension point to generate an alias for an existing value.
   This is needed as some modules such as String/Int are frequently
   used to create certain `Id` modules so it's valuable to be able to
   create values that can.

```ocaml skip
[%%dotnet_bin_prot.alias type t = string]
```

If you are declaring alias in a functor, you should use
`dotnet_bin_prot.functor` to avoid name collision.

```ocaml skip
[%%dotnet_bin_prot.functor
   type t = string
   let unique_module_path = "A.B.C"
   ]
```

3. Use a function from `[Dotnet_bin_prot]` to create a value. For more
   details you can take a look at `runtime-lib/dotnet_bin_prot.mli`

   This is needed when generating metadata for a type that depends on
   some functor arguments.


This will type check that the payload makes sense (so you can do
something like [type t = Stable.V1.t = { ... }] for example) and
generate a value that will result in a separate F# type that is type
equal.

## Generator
The values generated by the ppx are used to generate corresponding F#
types. In order to generate the types you specify all OCaml types
you're interested in being able to deserialize in F# and all those
types, along with any needed dependencies, will get generated. If
there are shared dependencies we will only generate a single file for
each of them.

If some of the types you are generating have custom serialization they
should be created by hand (most likely generated using this generator
and then modified) and specified as an override when using the
generator.

You can see an example generator binary at:
`lib/dotnet-libs/bin_prot/ppx/generator/bin/dotnet_bin_prot.ml`.
